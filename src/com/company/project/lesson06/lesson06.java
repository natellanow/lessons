package com.company.project.lesson06;

import com.company.project.lesson06.books.Author;
 /* com.company.project
    в папке src создают структуру пакетов таким образом.
    Доменное имя компании наоборот, потом название проекта
    Каждая точка это физически отдельная папка, т.е.
    com. в этой папке ничего кроме папки company
    В company - папка project
    а в папке project любая вложенность согласно логике:
    напр. package01
          package02...
это для того, чтобы не было конфликтов с именами.
*/

/*
public class в файле может быть только один
если класс public, то имя класса должно соотв имени файла
иначе ошибка компиляции
не public классов в файле мб сколько угодно
если класс идет с модификатором public, то его можно будет исп в любом участке папки src
если не public, то такой класс будет видно только внутри текущего пакета
весь код делится в зависимости от функционала на классы
в классах описывают, что должны делать те или иные сущности программы
потом на основе классов создают объекты и уже объекты будут выполнять тот код, что пишем в классах
функционал, набор методов определяется типом данных
доступно при обращении через переменную
 */

/*
после создания package books
допустим надо хранить инфу о книгах и об авторах
с этой целью будем создавать классы
 */

/*
чтобы создать экземпляр класса или объект, сначала указываем тип данных
т.е. после оператора присваивания идет оператор new
а автор и () это вызов конструктора
вызов конструктора всегда соответствует имени класса
мы создали класс Author в файле java Author значит его и пишем
объект помещается в heap память и находится там
ссылка на него в переменной author
по функционалу, который есть у Author мы можем узнать все если перейдем в тип данных Author
т.е. у этого объекта author есть id, name, email (в java файле)
т.к. мы пока только инициализировали переменные id, name, email - они равны 0, null, null
мы не могли задать изначально значение переменным в файле java, потому что получилось бы, что два автора с именем Марк например
для доступа к свойствам объекта используется точка
обращаемся к объекту по ссылке, переменная author01 ссылается на объект new author()
на этот объект еще может быть куча ссылок
если перед свойством стоит модификатор public, то подобный доступ к свойству будет доступен из любого участка программы
отсутствие public это package privat или default (одно и то же)
опять же если отсутствует, то обратится к свойству можно будет только внутри текущего пакета
т.е. именно здесь, в этом пакете, нельзя будет обратиться к свойствам из author java
new Author() - дефолтный конструктор, в скобках пусто(без аргументов)
когда создается класс у него уже есть дефолтный конструктор
если нам нужен другой конструктор помимо дефолтного, то нужно его описать
допустим мы хотим, чтобы каждый раз при создании нового автора в консоль выводилась соответствущая информация
public Author() {
        System.out.println("Author created");
        (по типу scanner(system.in)
конструкторы тоже создаются с модификатором (public), дальше имя конструктора такое же как и имя класса (author)
круглые скобки, пока пустые, потом фигурные скобки, все инструкции которые мы напишем в рамках этих фигурных скобок будут выполняться
System.out.println("Author created")
конструктор по прежнему с пустыми круглыми скобками, ничего в них не передаем, соотв такими их и объявляем
но добавляем функциональность
допустим мы хотим, чтобы наши авторы как и сканеры могли в конструктор принимать какие-то значения
например, при создании авторов мы могли передать туда идентификатор, не потом задавать когда нибудь, а сразу при создании объекта
и чтобы этот идентификатор стал значением свойства Id
вместо такой записи (author01.id =1;) ----- сразу вот сюда  Author author01 = new Author(1);
т.е. когда конструктор автора вызывается происходит одно и то же
создается переменная int, ей присваивается то значение, которое передается при вызове
дальше выполняется инструкция system out print "Author created"
получается каждый раз когда конструктора authorА вызывается инструкции выполняются

наверху импорт пакета - где лежит автор к которому обращаемся


 */
public class lesson06 {
    public static void main(String[] args) {
        Author author01 = new Author(1);
        Author author02 = new Author();
        //author01.id =1;
        author01.name = "Ольга";
        author01.email ="olga@gmail.com";
        System.out.println(author01.name);

        Author author02 = new Author(2); //тут только id, остальные null
        Author author03 = new Author("Макар"); //тут 0, и почта null
        Author author04 = new Author(3, "Саша", "sasha@gmail.com"); //тут все значения
    }
}
