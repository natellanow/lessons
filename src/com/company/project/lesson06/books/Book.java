package com.company.project.lesson06.books;
/*
идентификатор - обязательное свойство
название - обязательное свойство
кол-во страниц -
цена - обязательное свойство
авторы - массив авторов, а не строк, т.е. тип данных Автор, описанный в классе автор, целиком с его данными
и обратится к этому массиву можно по переменной после квадратных скобок
если есть обязательные свойства - значит это конструктор,
потому что если свойства задавать необязательно, то значит оно может остаться без какого-то конкретного значения
со значением по умолчанию, а дальше по возможности, либо задается, либо нет

Если мы пишем какой-то класс, значит мы описываем правила создания новых объектов, правила поведения объектов
в мыслях мы можем представить какие есть ограничения у значений - например они не могут быть отрицательными.
Когда объект будет создаваться мы не застрахованы, что будут переданы такие значения:
                 Book book01 = new Book(-1, "", -100) например
все проверки входящих данных ложатся на нас:
                 id > 0; price > 100, title - не пустая строчка
т.е. если значения не валидные, то операции присваивания выполняться не должны

 */
public class Book {
    private int id;
    private String title;
    private int numberOfPages;
    private int price;
    private Author[] authors;
    /*
    если модификатор privite, то свойства или конструктор недоступны нигде кроме как в текущем классе
    тек класс это открывающая фигурная скобка и закрывающая
    book01.price = -100 вот это нельзя написать в lesson06
    значение price может быть обновлено (например цена стала выше), плюс к этому надо задавать кол-во страниц
    и иметь возможность указывать авторов.
    например, если свойство задается через конструктор и мы не готовы его потом менять, тогда мы эту возможность и не предоставляем.
    а если нужно устанавливать или менять значения каких-то свойств, то мы должны предоставить такую возм-ть.
    этот доступ к изменениям описывается через методы, которые устанавливают значения свойств.
    если методы занимаются тем, что устанавливают значения свойств, то они называются сеттерами.
    например значение id и title не хотим менять, значит никаких методов, которые их устанавливают нет будет.
    а вот number of pages и price будем менять в программе для них и пишем сеттеры.
    public void setPrice(int price) {
          this.price = price;
     */

    public Book(int id, String title, int price) { //конструктор, можно через generate
        //здесь ниже код о том, что, либо объект создается с правильными данными, либо не создается вообще
        // идет проверка и если данные невалидны, то выбрасывать исключения
        // т.е. создается объект ошибки "неправильные аргументы" (IllegalArgumentException)
        // throw значит, что мы выбрасываем его
        // программа дальше выполняться не будет и в консоли будет сгенерировано исключение в котором написано, что
        // "id должен быть положительным".
        // получается что если такое исключение генерируется в программе, то при вызове конструктора разработчик сразу об этом поймет
        // если данные придут не те, то книги просто не будет.

        if (id<=0)
            throw new IllegalArgumentException("id должен быть положительным");
        if (price<=100)
            throw new IllegalArgumentException("price должен быть больше 100");
        if ("".equals(title))
            throw new IllegalArgumentException("title не может быть пустой строкой");

        if (id > 0) this.id = id;
        if (price>100) this.price = price;
        if (title != null && !title.isEmpty()) this.title = title; // можно еще !title.isEmpty() !title.equals("")


        // if(title != "") так нельзя, потому что строки это ссылочный тип, операторы сравнения с ними не используем
        // т.е. для строк это всегда методы, как и для массивов (arrays.equals например)
        // нужно еще проверить код на ввод null у title, но так: if (!title.isEmpty() && title != null) нельзя
        // потому что программа упадет уже на !title.isEmpty(), поэтому сначала должна быть проверка на null
        // !"".equals(title) метод вернет false, но если так !title.equals(""), то проверка на null обязательна
        }

        //сеттеры
    public void setPrice(int price){
        this.price = price;
    }
    public void setNumberOfPages (int numberOfPages) { // здесь будет 132 - int numberOfPages = 132
        this.numberOfPages = numberOfPages;
    }
    // геттеры, функционал чтения
    public int getId() {
        return id;
    }

    public String getTitle() {
        return title;
    }

    public int getNumberOfPages() {
        return numberOfPages;
    }

    public int getPrice() {
        return price;
    }
     /*когда идут методы сначала идут модификаторы доступа, потом либо void, либо какой-нибудь тип данных
     потом имя метода (должно отражать что там происходит), если устанавливает - значит set
     если метод обновляет, то update
     если возвращает, то get
     если печатает, то print и что печатает
     потом круглые пустые скобки
     но если в них перечислены аргументы, то и при вызове мы эти значения должны передать
     в теле метода описывается что будет происходить.
     если метод void, то результат его работы мы не можем сохр в переменную, не можем использовать для проверок в циклах или if
     т.е. метод отработал, что-то сделал внутри
     в нашем случае установил значение свойства
     и ничего про результат своей работы не сообщил
     также мы не сможем результат вывести в консоль
     а если стоит тип данных, то можно сохранить в переменную
     например:
     public int getPrice() {
     return price;
     }
     int price = book.getPrice()

     также если стоит тип данных вместо void, то return обязательно, так как он может вернуть результат своей работы

     в void методах можно использовать return, но только для того, чтобы завершить работу метода
     при каких-нибудь условиях
     например
     public void getPrice(int price) {
     if (price<= this.price) return;
     this.price=price;
     }
     если price, который пришел в метод, будет меньше текущего значения, значит метод завершит свою работу
     return как бы break для цикла
в любом случае когда программа встречается с return - метод свою работу завершает неважно какой тип

public void addAuthor(Author author) {}
тут добавить авторов в массив authors
самое первое, что нужно - инициализировать массив

      */
}

