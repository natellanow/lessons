package com.company.project.lesson06;

import com.company.project.lesson06.books.Author;
import com.company.project.lesson06.books.Book;
import com.company.project.lesson06.flowers.Bucket;
import com.company.project.lesson06.flowers.Flower;
 /* com.company.project
    в папке src создают структуру пакетов таким образом.
    Доменное имя компании наоборот, потом название проекта
    Каждая точка это физически отдельная папка, т.е.
    com. в этой папке ничего кроме папки company
    В company - папка project
    а в папке project любая вложенность согласно логике:
    напр. package01
          package02...
это для того, чтобы не было конфликтов с именами.
*/

/*
public class в файле может быть только один
если класс public, то имя класса должно соотв имени файла
иначе ошибка компиляции
не public классов в файле мб сколько угодно
если класс идет с модификатором public, то его можно будет исп в любом участке папки src
если не public, то такой класс будет видно только внутри текущего пакета
весь код делится в зависимости от функционала на классы
в классах описывают, что должны делать те или иные сущности программы
потом на основе классов создают объекты и уже объекты будут выполнять тот код, что пишем в классах
функционал, набор методов определяется типом данных
доступно при обращении через переменную
 */

/*
после создания package books
допустим надо хранить инфу о книгах и об авторах
с этой целью будем создавать классы
 */

/*
чтобы создать экземпляр класса или объект, сначала указываем тип данных
т.е. после оператора присваивания идет оператор new
а автор и () это вызов конструктора
вызов конструктора всегда соответствует имени класса
мы создали класс Author в файле java Author значит его и пишем
объект помещается в heap память и находится там
ссылка на него в переменной author
по функционалу, который есть у Author мы можем узнать все если перейдем в тип данных Author
т.е. у этого объекта author есть id, name, email (в java файле)
т.к. мы пока только инициализировали переменные id, name, email - они равны 0, null, null
мы не могли задать изначально значение переменным в файле java, потому что получилось бы, что два автора с именем Марк например
для доступа к свойствам объекта используется точка
обращаемся к объекту по ссылке, переменная author01 ссылается на объект new author()
на этот объект еще может быть куча ссылок
если перед свойством стоит модификатор public, то подобный доступ к свойству будет доступен из любого участка программы
отсутствие public это package privat или default (одно и то же)
опять же если отсутствует, то обратится к свойству можно будет только внутри текущего пакета
т.е. именно здесь, в этом пакете, нельзя будет обратиться к свойствам из author java
new Author() - дефолтный конструктор, в скобках пусто(без аргументов)
когда создается класс у него уже есть дефолтный конструктор
если нам нужен другой конструктор помимо дефолтного, то нужно его описать
допустим мы хотим, чтобы каждый раз при создании нового автора в консоль выводилась соответствущая информация
public Author() {
        System.out.println("Author created");
        (по типу scanner(system.in)
конструкторы тоже создаются с модификатором (public), дальше имя конструктора такое же как и имя класса (author)
круглые скобки, пока пустые, потом фигурные скобки, все инструкции которые мы напишем в рамках этих фигурных скобок будут выполняться
System.out.println("Author created")
конструктор по прежнему с пустыми круглыми скобками, ничего в них не передаем, соотв такими их и объявляем
но добавляем функциональность
допустим мы хотим, чтобы наши авторы как и сканеры могли в конструктор принимать какие-то значения
например, при создании авторов мы могли передать туда идентификатор, не потом задавать когда нибудь, а сразу при создании объекта
и чтобы этот идентификатор стал значением свойства Id
вместо такой записи (author01.id =1;) ----- сразу вот сюда  Author author01 = new Author(1);
т.е. когда конструктор автора вызывается происходит одно и то же
создается переменная int, ей присваивается то значение, которое передается при вызове
дальше выполняется инструкция system out print "Author created"
получается каждый раз когда конструктора authorА вызывается инструкции выполняются

наверху импорт пакета - где лежит автор к которому обращаемся


 */
public class lesson07 {
    public static void main(String[] args) {
        Author author01 = new Author(1);
        Author author02 = new Author();
        //author01.id =1;
        author01.name = "Ольга";
        author01.email ="olga@gmail.com";
        System.out.println(author01.name);

        Author author02 = new Author(2); //тут только id, остальные null
        Author author03 = new Author("Макар"); //тут 0, и почта null
        Author author04 = new Author(3, "Саша", "sasha@gmail.com"); //тут все значения
        Book book01 = new Book(-1, "JDL21", -100); //такого быть не может
        book01.price = -100; //так уже нельзя будет написать, если в классе book будет класс private
        //т.е. ошибка доступа

        /*
        Book book01 = new Book(-1, null, -100);
        в классе book мы написали, что не могут передаваться такие значения, но ведь книга создана?
        она будет создана с дефолтными значениями!!!!!
        если программа считает, что это нормально - создавать с дефолтными значениями
        но если для нас категорически важно, чтобы книга создавалась с конкретными значениями, отличными от null
        то такой конструктор не подойдет - Book book01 = new Book(-1, null, -100);
        тогда тот кто вызывает конструктор должен об этом сразу узнать,
        понять что он передает невалидные данные и где-то сверху написать проверки получше
        чтобы в книгу передавались только валидные значения.
        поэтому идем в конструктор и даем понять тем кто будет вызывать этот конструтор, что
        книга либо создается с правильными значениями, либо не создается вообще
        идем в book.java
         */

        System.out.println(book01.id); // мы не сможем получить значение, так как Id со значением private
        //для этого создается отдельный функционал, называется getter

        book01.setNumberOfPages(132); //метод вызывается и туда идет 132
        book01.setPrice(200);
        System.out.println(book01.getPrice());
        Flower flower = new Flower(1,"азалия");
        Bucket bucket = new Bucket(3);
        bucket.getFlowers()[0] = flower;

        bucket.addFlower(flower);

        bucket.getFlowers()[0].setName("роза"); //это мы по ссылке на объект азалия обращаемся с целью замены на "роза"
                //метод getFlowers возвращает ссылку на массив такого типа : Flower[]

        /*
        здесь цветок Flower flower = new Flower(1,"ромашка"); - невалидный по нашим критериям
        (цветок не наичнается с а)
        и есть букет
        если бы мы воспользовались методом addFlower, то ромашка не попала бы в букет
        но у букета есть getter
        getter возвращает ссылку на массив, обращаемся к любому допустимому элементу массива [0]
        и передаем туда любое значение
        и таким образом в массив могут попасть любые цветы
        также может попасть null ссылка - bucket.getFlowers()[0] = null;
        getterОВ на массивы быть не должно

         */

        for (Flower bucketFlower : bucket.getFlowers()) {
            bucketFlower.setId(10);
        }
        /*
        bucket.getFlowers() - ссылка на массив букета,
        bucketFlower - в этой переменной на каждой итерации цикла будет ссылка на элемент этого массива

         */
    }
}
