package lesson05;

import java.util.Arrays;

public class Arrays {
    public static void main(String[] args) {
/*
Массив — это непрерывный участок памяти,
содержащий последовательность объектов одинакового типа, обозначаемый одним именем.
Для объявления массива мы сначала указываем тип данных, дальше [], пробел не нужен
Дальше придумываем имя массива
Если речь идет об объявлении с присваиванием, с инициализацией, то пишем оператор new,
потом снова тип данных и в [] указываем размер
 */
        // массив на 5 элементов,
        // заполненный дефолтными значениями
        double[] prices = new double[5]; // пустой массив на 5 элементов*
        // 5 - длина массива
        // [0.0, 0.0, 0.0, 0.0, 0.0]
        // целые числа - 0
        // числа с плавающей точкой - 0.0
        // логический тип - false
        // ссылочные типы - null

        // массив на 6 элементов,
        // заполненный пользовательскими значениями
        int[] temps = {45, 90, 122, 33, -3, 67};
        System.out.println(temps[2]); // 122 - чтение, вывод значения массива
        /*
        т.е. чтобы получить конкретное значение по индексу мы обращаемся к массиву
        ставим [] дальше ставим индекс того элемента, который нам нужен
         */
        prices[1] = 10.6; // [0.0, 10.6, 0.0, 0.0, 0.0] // тут идет замена значения

        /*
        каждый элемент массива находится в нем под индексом
        индексы исп для доступа к элементам
        первый элемент под индексом 0, след под 1 и т.д.
         */

        System.out.println(temps); // запросив вывод массива таким образом мы увидим не массив, а хэшкод объекта
        // import java.util.Arrays;
        System.out.println(Arrays.toString(temps)); // чтобы посмотреть на массив целиком так как он есть

        /*
        для разнообразных операций с массивами (поиск, сравнение, вывод в консоль, сортировки)
        пользуемся функционалом класса arrays
        у массива нет большого набора методов, чтобы производить какие-то операции
        у массива есть например метод length возвращает длину массива
         */
        System.out.println(temps.length); // 6

        System.out.println(temps[temps.length-1]); // вывод значения последнего элемента массива

        // java.lang.ArrayIndexOutOfBoundsException
        // System.out.println(temps[10]); выход за пределы массива, исключение времени выполнения
/*
и индексы, и длина они могут задаваться либо через числовые литералы, либо через переменные,
либо через выражение, главное чтобы эти выражения возвращали тип int
т.е. и длина, и индекс это тип int
обычно мы массивы не видим
чтобы смотреть на каждый по отдельности элемент массива через индекс - неудобно
тогда чтобы перебрать массив используются циклы
чаще всего это for
 */
        // fori
        // for

        /*
        начинаем перебор с начала (0), на каждой итерации цикла мы можем
        увеличивать значение индекса на 1
        либо на любое другое значение, если мы хотим перескакивать
        и если мы идеи от первого элемента,
        то идем вверх (index < prices.length) пока элементы не закончатся
        когда индекс будет = длине массива это значит
        что элементов там больше нет и цикл закончится
        если мы будем идти от последнего элемента к первому,
        то индекс будет последний элемент массива (-1)
        на каждой итерации цикла значение индекса будем уменьшать на 1 или другое значение
        и условие будет - пока не дойдем до нулевого индекса (index < 0)

         */
        for (int index = 0; index < prices.length; index++) {
            System.out.println(prices[index]);
            prices[index] += 10; // [index] - так получаем доступ к элементу массива и можем производить любые операции

        }
        // int[] temps = {45, 90, 122, 33, -3, 67};
        // перебрать массив temps, температуры ниже 0
        // заменить на 0,
        // двигаться от последнего элемента к первому
        for (int index = temps.length - 1; index >= 0; index--) { // на каждой итерации индекс должен уменьшаться иначе мы не будем двигаться
            if (temps[index] < 0) temps[index] = 0;
        }


        // for each, всегда перебираем массив целиком, всегда от 1го элемента к последнему,
        // без пропусков, нет возможности перепрыгивать через элементы
        // изменить значение элементов нельзя
        // for (типДанных имяПеременной: массив) {
        //
        // }

        // iter
        for (int temp : temps) {
            System.out.println(temp); // на каждой итерации - значение элемента
        }
        for (var price : prices) {
            if (price > 100) {
                System.out.println(price);
                break;
            }
        }
        // найти сумму элементов массива temps
        // {45, 90, 122, 33, 0, 67}

        int sum = 0; // если надо найти сумму, то ее надо где-то накапливать, где-то хранить
        for (int temp : temps) {
            sum += temp;
            System.out.println(sum);
        }


        int sum = 0;
        for (int temp : temps) {
            sum += temp;
        }
        System.out.println(sum);

        // класс Arrays, бинарный поиск только для сортированного массива
        int[] ids = {3, 6, 8, 10, 22, 45}; // 100
        System.out.println(Arrays.binarySearch(ids, 8)); // 2 - индекс элемента
        System.out.println(Arrays.binarySearch(ids, 100)); // -7 проверки на отрицательное значение достаточно

        Arrays.sort(temps); // sort ничего не возвращает, результат не можем сохранить в переменную
        // метод sort меняет исходный массив
        System.out.println(Arrays.toString(temps));

/*
если в массиве примитивы например, или строки, нельзя заменить значение элемента,
т.е. в этом цикле нельзя обратиться к элементу, нельзя обратиться к одному элементу и перезаписать значение,
 */
        for (int id : ids) {

        }

        /*
        но в цикле мы можем обратиться к объекту поставить точку и заменить значение его свойств,
        главное ссылку не перезаписывать
        именно элемент вырезать и заменить нельзя
        но если у объекта есть какие-то свойства, которые можно заменить, то они будут заменяться

        class A {
        public int aV;
        }
        for (A a : asArr) {
        a.aV = 12;
        }

        к этому еще вернемся когда будем проходить классы и объекты

        ссылку заменить нельзя, а по ссылке можно обратиться к объекту

         */
        

        /*
        тут массив строк, на каждой итерации в переменной будет ссылка на элемент массива
        на первой итерации color это будет red, на второй blue, на третьей orange (это если нет null пример)
     и программа завершит свою работу.
     но если есть null - помним что у null не может быть методов иначе будет ошибка
     поэтому пишем ниже if (color != null) - значит только если не null, то выполняем операции
         */
        String[] colors = {"red", "blue", null, "orange"};

        for (String color : colors) {
            if (color != null) System.out.println(color.toUpperCase());
        }

        int a = 9;
        int b = a;
        // a 90
        // b 10

        // String[] colors = {"red", "blue", null, "orange"};
        // String[] newColors = colors; // т.е. под новый массив newColors не выделяется память,
        // в памяти только один массив и обратиться можно к нему через 2 переменные colors и newcolors
        // т.е. получили две ссылки на одну и ту же область памяти, на один и тот же объект
        // colors -> {"red", "blue", "null", "green"}
        // newColors -> {"red", "blue", "null", "green"}

        // для массива есть 3 возм создания копий
        String[] newColors01 = colors.clone(); // вызов метода clone, будет 2 независимых!!! массива (не как вверху)
        String[] newColors02 = Arrays.copyOf(colors, 2); // неполные копии, кол-во элементов хотим скопировать 2 например, выход за пределы массива возможен
        // // String[] colors = {"red", "blue", null, "orange"};
        String[] newColors03 = new String[colors.length * 2]; // т.е. копирование в новый массив, массив подготавливаем изначально


        // [null, "red", "blue", null,"orange", null]
        System.arraycopy(colors, 0, newColors03, 1, 3);
        // здесь выше - сперва из какого массива копируем, потом - начиная с какого элемента копируем,
        // потом в какой элемент складываем значения, потом - начиная с какого элемента в новом массиве будут сохр значения
        // потом - сколько элементов нужно скопировать и выйти за пределы массива мы не можем

        String[] colors01 = {"red", "blue", "orange"};
        String[] colors02 = {"red", "blue", "orange"};

        System.out.println(colors01 == colors02); // false
        /*
        false потому что, работаем с ссылочными типами и сравнение через оператор равенства будет сравнивать ссылки
        проверяет - переменная colors01 ссылается ли на тот же самый массив, что и переменная colors02
        также метод eauals для ссылочных типов исп нельзя, потому что он работает также как и ==
        если нужно сравнить значение элементов массива, то пользуемся методом equals из класса arrays - Arrays.equals(colors01, colors02)
        */

        System.out.println(colors01.equals(colors01)); // аналогично ==
        System.out.println(Arrays.equals(colors01, colors02));




    }
}